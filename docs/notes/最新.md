## 1.Java 基础

### bio，nio

bio面向流，nio面向块，

nio实现了io多路复用的reactor模型，一个线程通过selector通过轮询的方式去监听多个channel上的事件，

一般服务器一直轮询是否有事件到来，来了就执行相对应的事件。

### **RPC**

channel，buffer

![img](http://p9.pstatp.com/large/pgc-image/b0263579cc9d4eff98922f479a17beac)

1）服务调用方（client）调用以本地调用方式调用服务；

2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；在Java里就是序列化的过程

3）client stub找到服务地址，并将消息通过网络发送到服务端；

4）server stub收到消息后进行解码,在Java里就是反序列化的过程；

5）server stub根据解码结果调用本地的服务；

6）本地服务执行处理逻辑；

7）本地服务将结果返回给server stub；

8）server stub将返回结果打包成消息，Java里的序列化；

9）server stub将打包后的消息通过网络并发送至消费方

10）client stub接收到消息，并进行解码, Java里的反序列化；

11）服务调用方（client）得到最终结果。

**RPC框架的目标就是要2~10这些步骤都封装起来。**

#### 涉及技术

##### 1.建立通信

客户端和服务器之间要建立tco连接，整个数据传输都是在这个连接基础上完成的。

##### 2.服务寻址

###### 2.1服务注册

其实这个主要是为了后续的服务发现用的，首先就是把当前服务端的信息存储在注册中心，IP，port，protocl，serializaable，实际上就是在zk上创建了一个znode节点，存储了上述服务信息。

###### 2.2服务发现

消费者第一次调用服务时，回去通过注册中心来获取相应服务的IP地址列表，并且缓存到本地，一共后续使用。当消费者再去调用服务时，就直接通过负载均衡算法在本地缓存中找出一个服务提供者来调用服务。

###### zk执行过程

服务者启动后主动向zk注册ip，port，service，

消费者调用服务时向zk获取一份服务提供方地址，zk可以实现负载均衡。failover

服务者需要定时向zk发送心跳。来确保自己来可以提供服务。

##### 3.网络传输

用什么协议，如何序列化。

##### 4.通信方式

NIO，基于netty框架的。

##### 5.**负载均衡策略**

随机

轮询

最少活跃度

一致性hash

##### 6.**Dubbo的集群容错方案**

failover：自动切换，读操作

failfast：失败就报错，非幂等的写操作。

failsafe：失败安全，出现异常直接忽略，写日志

failback：失败自动恢复，定时发送，一般用于消息通知

forking：并行调用多个，只要有一个就行，读操作

broadcast：带哦用所有提供者，有一台出错就报错，通知其他服务者更新资源。

##### 7.**Dubbo超时时间怎样设置？**

提供者设置超时事件，

##### 6.服务调用整个流程

首先A调用方法，就会在本地产生一个clientstub来将要调用的服务封装成一个序列化消息，然后通过网络通信传到B，B会用一个serverstub来接受这个消息，并且解析消息，然后执行消息对应的本地方法，然后再将该方法的返回值封装在消息中，通过网络在发送给A，clientstub接收到消息之后，在进行解析，，最后得到答案，返回给本地方法。





### final

修饰类，类无法被继承

修饰变量，变量不可变，引用不可以变。

修饰方法，表示方法不可被复写。

### compare和comparator



## 2.Java容器

### 1.arraylist

#### 扩容

每次添加元素时，都会去检查是否需要扩容，如果需要就生成一个1.5倍的数据，将所有元素复制过去。

#### 删除

将该位置之后的全部往前赋值。

#### fail-fast

modcount是用来记录结构表变化的次数的。

每次在迭代或者序列化时，都会去检查modecount是否改变，如果改变就抛异常Concurrentmodificationexception。

#### 序列化

序列化，就是一个标志，证明该类可以序列化，在序列化时不会序列化transient关键字修饰的变量，static变量也不会序列化，serializableid会标识唯一一个类，序列化前后要保持一致，不然无法反序列化。

### 2.copyonwritearraylist

写操作在一个复制数组上进行，读操作还是原来的数据，读写分离。

写操作要加锁，防止并发写时写入数据丢失。

写操作结束原始数组指向只想新的数组。

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
```

### 3.hashmap

### 实现原理

数组+链表/红黑树

### 计算hash值

key.hashcode高16位和低16位异或。

### put操作

通过hash&(cap-1)来确定数组下标

1.该hash位置没有数据，就在该位置上直接存储。

2.该索引位置有数据，判断数组中的该位置key是否一样，直接替换。

如果不一样，就会记下当前节点，和索引位置节点，然后先看该位置节点的next是否为空，如果为空，

### 扩容

就直接是之前的2倍，新建了一个数组，然后遍历以前的数组，将每一个node都只想空，若果当前，节点没有后继节点直接放到新数组中，如果有的话，就分别设置两个头尾节点，来分别表示新数组的两个位置链表头尾，然后便利整个链表，采用**尾插法**来新建链表，最后，将每个链表的头节点放在新数组中，是通过hash&oldcap来判断是否需要移动到新索引位置处。

cap原本就是2的整数幂，所以二进制表示就只有一个1其余全是0，和hash&，判断是否应该在新数组下标中。

## 4.concurrenthashmap

### put操作

数组对应下标位置无数据，cas尝试将数据存在该位置。

如果有了，就获取头节点对象的锁，并且在if判断一下是否位该对象，在进行或许操作。

### 阻塞队列

put方法 通知等待

# 3.java并发

### 进程通信方式

管道，消息队列，共享内存

### 处理器实现原子操作

总线加锁，缓存加锁

总线加锁

就是一个线程在读改写共享变量时，其他线程不能操作共享内存。cpu不能访问内存。

缓存加锁

### 缓存一致性

每个缓存行有4中状态：m，e，s，i

分别代表修改，独占，共享，无效

cache操作也有4种：local read，local write，romote read，remote write

本地读，本地写，远程读，远程写

m状态下：当前状态为最新状态，其他cache全为无效。主存也是以该cache为准。

lr：直接读，

lw：直接写

rr：当前cache写入主存，然后状态改为s

rw：写入主存，然后改为i

### 伪共享

缓存行：每一次cpu会读取64字节的数据进缓存，然后每个线程都是这样，当其中一个线程的缓存行发生了改动，就会将其他线程的缓存行状态改为无效，就需要重新从主存中加载进来，浪费性能。

伪共享就是有两个不相干的变量在同一缓存行中，当其中一个改变了，整个缓存行都会被标记无效，访问另一个没有改变的变量也需要重新读取主存。心态崩了。

### CAS

一般都是用来改变valatile变量的，原子操作。如果当前值为期望的值，就将当前值改为目标值，如果不是就不改变。

问题：ABA问题，占cpu资源，只能为一变量使用。

### volatile

写内存语义：当有人写valite变量时，会直接更新到主存中，

读内存语义：有人读时，直接从主存读取。

ABA问题，循环时间长，只对一个变量有用

### threadlocal

本地线程存储变量，set时，会获取当前线程的threadlocals对象，时threadlocalmap类型的，设置一个key为当前线程，value为设置值的一个map。

### AQS

每个同步器都有一个同步队列和多个等待队列。

独占和共享区别

独占是state同步状态初始值为0，当有人获取同步变量时，会加一。

共享是state同步状态初始值为设置的大于0的值，来一个获取一个，就减一。

### 1.synchronized和Reentrantlock

先讲一下AQS,reentrantlock是通过AQS实现的，有两个内部类继承了AQS，公平锁和非公平锁。

我们通过调用链来讲解整个流程。

lock-syn.lock-aquire-(tryaquire&addwaiter()&acquirequeue())

#### tryaquire()

该方法是AQS的protected访问方式的函数，被reentrantlock内部的类实现了，只要就是通过cas来尝试获取state同步变量，使其加一。公平锁和非公平锁实现不同，公平锁会在cas之前判断同步队列是否有人比我排队时间长如果有的话，我就不cas。

#### addWaiter()

如果获取同步状态不成功，就把自己封装成一个node结点，并且尝试添加到同步队列队尾中，失败了就enq()函数一直尝试添加到同步队列队尾。

#### aquirequeue()

添加至队尾之后，就让该线程一直自旋，但也不会那么sb，首先获取该节点的前驱结点，如果为head结点，在尝试获取同步状态，因为head节点是已经获取同步状态的节点。这样就可以减少cpu的消耗，可以尝试阻塞该线程，依靠前驱节点的出队或者被中断来唤醒当前线程。这样就会满足fifo原则。

#### condition对象

上面讲的是正常的获取锁的过程，下面我们来看看等待通知模式。

等待队列，等待，通知。

这个conditonobject是AQS的内部类，里面新添加了两个节点，都是node类型的。firstWaiter，lastWaiter，分别用于等待队列的对头和队尾。

conditionobject.await()

首先将该线程狗造成节点添加到等待队列中，然后再释放同步状态。唤醒同步队列的后继节点。然后进入等待状态。等待其他线程的signal来唤醒该线程，并且活在signal方法中将该节点从等待队列中删除，并调用enq()尝试将该节点添加到同步队列，返回await()方法继续执行acquirequeue方法尝试获取同步状态。整个过程结束。

就是同步队列的head节点移动到了等待队列的队尾。

### 读写锁

就是将state的高16作为读锁，低16位作为写锁。

trywritelock

state只要大于0，就证明有人已经获取锁了，不管是读锁还是写锁。就可以返回了。

tryreadlock

先判断是否为独占锁（写锁），如果不是就直接把高为再加上一个1就行。

### synchronized

偏向锁

首先cas尝试获取锁。

1.检查当前锁对象中markword偏向锁是否是当前进程，如果是，就执行同步代码，否则进入2

2.检查偏向锁是否为1，如果没设置，就直接cas竞争锁，否则进入3

3.cas尝试将对象头中的进程id设置为当前进程。若成功，执行同步代码，否则进入4

4.锁升级为轻量级锁，jvm会将当前线程的栈帧中创建用于存储所记录的空间，并且将对象头的markword复制到锁记录中，并且cas尝试将对象头的markword指针指向锁记录。如果成功就执行同步代码，否则进入5

5.升级为重量级锁，就会阻塞其他等待线程，一直到当前线程释放锁。

### countdownlatch

原理：是基于AQS实现的同步器，共享锁，正如上面AQS中所写共享锁获取同步状态是将state-1，

tryacquireShared（），如果同步状态state不等0时，就会返回-1,会进入同步队列，继续判断同步状态是否为0，不等于0就返回-1，并且一直线判断是否头结点的后继节点，然后在判断同步状态，否则直接阻塞一段时间，

```java
protected int tryAcquireShared(int acquires) {
	return (getState() == 0) ? 1 : -1;
}
```

await()

该方法会调用AQS中的方法来执行countdownlatch中的tryacquireshared()方法。只有当该方法返回值大于0，程序才能继续执行下去。否则一直等待。

countdown()

会去调用tryreleaseshared相应减一判断是否为0，不为0，返回true，就能进入doreleaseshared方法中，在该方法中要改变当前节点状态信息。

### blockingqueue

里面有一个reentrantlock，和两个condition对象，来实现满和空的等待通知。object数组。

### 线程池

线程池设计

excute，shutdown，addworker，removeworker，getjobsize，initworker

threadpool类定义字段：

list<worker>,list<job>,size,

excute()

把当前job加入list，并通知work线程。

addworker()

new thread()即可。

```java
class woker{
	run(){
		jobs.await();
		job.run();
	}	
}
```

### ThreadPoolExecutor

执行原理：首先来了任务，就创建线程一直到coresize为止，当运行的线程多于或者等于coresize，就把当前任务加入阻塞队列，然后当阻塞队列满了之后，就创建新的线程来执行后来的任务，需要获取全局锁。当线程数超过maxsize，会进行相应的丢弃策略。

每个线程封装成worker对象去执行相应的方法，run就是从阻塞队列去第一个任务，然后完成之后，再将线程放到线程池中。

### 生产者消费者模式

用阻塞队列来实现。wait，notify都可以。

## HTTP

### cookie和session

他俩都是为了弥补http无状态协议的，

cookie和session都是用来存储用户数据的，不过cookie是存放在客户端上，session是存放在服务端，

cookie保存的数据有大小限制，并且不安全，别人可以获取，可以伪造。

session是将数据保存在服务器端，对于大小没有限制，session会创建一个sessionid，放在hashtable中，用来获取数据，一般都是把sessionid放在cookie中，然后通过cookie来获取session对象来获取用户数据。

### http和https

http 80/tcp

https 443/tcp

http是无状态，无连接的。基于tcp/ip的超文本传输协议。可以传送任何对象。简单。

https是加了认证和加密的http，他会在服务两端加上一个加密算法，用的是非对称加密和对称加密。

非对称加密：就是说服务两端每人都有各自的一套公钥密钥，然后每次传输时都将对方的公钥带上，然后自己接收到数据，就可以解密。但是如何确保公钥时正确的，这就需要一个认证机构，服务器将自己的公钥给认真机构认证，认证成功之后，再将他发给客户端，然后客户端通过认证机构颁发的证书进行比对，来确认公钥的正确性。

https：是用非对称加密来发送对称加密中的密钥，在建立连接之后，就一直用对称加密通信，这样消耗更小，速度更快。

### 请求消息和响应消息

请求行，请求头，空行，请求数据。

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

相应行，响应头，空行，相应数据。

```
HTTP/1.1 200 OK	版本号，状态码，状态消息
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

### http状态码

1.提示信息，2成功，3重定向，4客户端错误，5.服务器错误。

200成功

302临时重定向

304资源没变

500服务器内部错误

### get和post

get，post都是客户端向服务器请求资源的方式。

get一般请求资源，post则是提交资源。

get提交的数据是放在请求头中，post把提交的数据是放在请求正文。

## spring

### ioc

定位载入注册 

控制反转就是将管理对象的权力移交给了spring容器，让spring来管理对象的整个生命周期，目的为了解耦。

如何做的？

主要是通过反射。

首先spring先将xml文件读入resource对象中，然后遍历所有标签，创建beandefiniton对象，将读到的属性值保存到该对象中，然后把<id,beandefinition>键值对缓存到map中，最后getbean时会通过id拿到对应的beandefinition，然后再通过反射创建对象实例。

#### aop

效果就是可以在一个方法执行前后条件上一些其他功能，但是并不会影响到原有代码的完整性，也是一种解耦。把一些公共的代码封装起来，模块功能正交化

jdk，cglib

jdk是通过生成一个接口的实现类并且继承proxy，并且在该实现类中通过静态代码块的方式获取所有方法，并且在实现的方法中调用父类的invoke方法执行代理类的目标方法。

cglib

生成一个委托类的子类，然后复写所有方法，每次被调用时都会查看是否绑定了监视器，如果有就跳过去执行监视器里的intercept方法。

jdk

根据接口生成实现类，实现类通过静态代码块来获取接口中的所有方法，并且在自己的实现方法中，会通过调用接口的方法.invoke，

会先去执行自己的实现方法，然后在该方法内回去执行这个方法的invoke，这个invoke方法被复写了，所以可以执行一些别的功能。

cglib

首先enchance绑定目标类，设置拦截器，生成代理对象，其实就是一个子类复写了方法，每次调用方法时，会被拦截器拦截，然后就会进入到invoke方法中，执行相应的其他功能吗，在执行nvokesuper方法，用来回调被代理类的方法，该方法全部通过索引将每个方法全部映射起来，直接通过索引来执行子类复写的方法。

### 循环依赖

### bean生命周期

![1551952102408](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1551952102408.png)

首先ioc容器实例化bean，调用构造方法然后在设置属性，调用set方法，在设置beanname，beanfactory，applicationcontext，再就设置初始化前方法，before，然后初始化init，然后after，到此初始化完毕，然后后面关闭容器时，会调用destory，要实现disposablebean，然后调用destorymethod。

### 依赖注入

三级缓存。就是先将其中一个bean对象的引用提前暴露出去，然后当另一个对象在依赖注入的时候就可以找到该对象的引用，从而完成自己的初始化，然后A对象在完成自己的初始化，但是只能解决setter注入，不能解决构造方法注入。

## 6.mysql

首先有服务器和存储引擎，sql执行过程，就是通过服务器将sql拿到，然后就给了存储引擎，引擎通过索引拿到相应行的数据，传到服务器端，在进行where过滤。

### 事务实现原理

### exists和in

exists是将最外面循环一直执行，然后每次都要判断内层循环有没有返回值，只要有，就加入结果集。

in是先将子查询的结果查出来，然后在按照这些子查询的结果来进行查询。

如果两个表大小有差距，子查询表大就用exists，子查询小的用in

### mvcc

多版本并发控制，他是一种轻量级控制并发的手段，就是在每条记录的后面都添加两列，当前版本号和删除版本号。创建时间和删除时间。每个事务执行的时候都会有一个版本号。只在读已提交，可重复读模式下可以使用

select：会查询当前事务版本之前的记录。

insert：每插入一行就会保存当前事务的版本号

delete：会记录删除的事务版本号

update：新插入一行保存当前版本号，并把当前版本号作为以前行的删除标识

### 事务隔离界别

读未提交，读已提交，可重复读，串行化

### 锁

悲观锁，乐观锁，行锁，表锁，读锁，写锁，意向锁

当前读，快照读，用于那些实时性不太高的地方，

select快照读，select for update，lock in share mode

### 数据库索引

b-tree，b+tree

btree每个节点可以存储记录地址，b+tree节点不存指针，b+tree每个叶子节点都是一个链表，且有序。是按照当前索引排序的。B+tree更加容易全表扫描有序。

所以b+tree查询的效率更加稳定，缺点都有，就是维护树的结构比较麻烦，

myisam

是将叶子节点记录数据位置，数据统一存储。

innodb

叶子节点就是数据，索引不能过长，辅助索引要查两次，最好是单调字段做索引。

### 索引优点

大大减少了服务器读取的记录行数

避免了服务器排序。

降低了IO，随机io变为顺序io

### 数据库优化

独立的列（索引单独放在表达式的一侧）

前缀索引（当索引字段特别长的时候会影响性能）

多列索引（组合索引）

选择合适的索引列顺序

聚簇索引

覆盖索引

索引扫描来排序

冗余和重复索引

未使用的索引

### varchar和char的区别

## 7.redis

incr,set,get,setnx,decr,keys *,exists,incrby,decrby,del

### 数据类型

string，hash，list，set，sortedset

string存的是字符串，基础类型

hash存的是对象属性，set key field value

list是通过双向链表实现的，可以在两端添加删除。push，pop，range，index keys index值，trim只保留指定范围的元素，insert keys value index

set使用hashtable来实现的，value为空，add,rem,sismemeber,adiff set1 set2

sortedset是用散列表+跳跃表实现的，跳跃表是一个链表，然后每隔2次提起一个节点并且连接起来，每个节点都有两个指针，一个指向同层下一个，一个指向下一层，最后会形成一个类似于树的一个结构，逐层查找。时间复杂度logn

zadd key score member zscore,zrange,zincrby,zcard(数量),zrem

### 数据持久化

rdb，aof

rdb是数据快照，当前进程开一个子进程用来写数据到rdb文件中，然后那些正在被使用的数据，就会复制一份在写入rdb文件中，写时复制。

aof是将redis执行的写命令都记录下来，然后等待系统重启之后一一执行。

但是有可能会有一些没有用的，也存在aof文件中？

可以设置当前aof超过上次重启的aof文件的百分之几之后会进行重写，只会记录上次重启之后发生的改变。重写只与内存的数据有关，和以前的aof文件无关。

还需要将aof文件从缓存写到硬盘上，可以设置固定时间执行次数.

数据淘汰策略

定期删除+惰性删除

rlu：通过linkedhashmap就是内部多维护了两个字段，head，tail，before，after。每次访问的节点都会加到双向链表的尾部。

## 8.mq

如何设计一个消息队列，感觉用阻塞队列，实现生产者消费者模式

## 9.Java虚拟机

gcroot

栈中的引用，方法去的静态引用，常量引用，本地方法栈的引用

### 引用

强引用，软引用，弱引用，虚引用

软引用：内存不足，就要回收该类对象

弱引用：下次就要回收

虚引用：就是一个标识

### GC

默认15岁进入老年代

### 类加载

加载，验证，准备，解析，初始化

加载

通过各种途径2获取类的二进制流文件。

将静态数据结构转化为运行时方法区的数据结构。

生成该类的类对象，作为数据访问的入口。

验证

文件格式验证

验证字节流是否符合java类型信息的要求。

元数据验证

语义校验，保证符合java语言规范的元数据。

类如：是否继承了不允许被继承的类final，不是抽象类，当时没有全部实现接口里的方法。

字节码验证

对方法体校验

符号引用验证

常量池的各种符号引用，是否符合描述符

准备

为类变量非陪内存，并初始化。

解析

符号引用转化为直接引用

初始化

static代码块static变量赋值

### 类加载器

每一个类都要由加载他的类加载器和该类本身一同确立其在Java虚拟机中的唯一性。由两个类加载器加载的同一.class文件，由同一虚拟机架子，最后这两个类还是不相等。instance of

### 双亲委派模型

是为了保护java程序的稳定运行，是这样实现的，在当前类加载器的loadclass方法中，首先先检查类是否已经被加载，如没加载就让他父类加载器加载，如果没有，既让启动类加载器加载，如果加载失败，自己在加载。

其实就是为了保护程序更加安全，如果我们自己定义的java.lang.object类你想要通过自己的类加载器加载的话，就会报错。如果有人想要加载object类，都会去请求到启动类加载器在lib中tr.jar中的类来加载。使得每一个类加载器加载的object类都是一样的。

### tcp拥塞控制

慢开始，拥塞避免，快重传，快恢复

这里有一个拥塞窗口的概念，发送窗口从0开始，进入慢开始阶段，每一个轮次就扩大2倍，直到发送窗口达到拥塞上限值，就会进入拥塞避免阶段，此阶段每个轮次发送窗口+1，直到出现真正的网络拥塞，然后就会将拥塞值设置当前发送窗口的一半，发送窗口设置为1，继续慢开始。

如果在拥塞避免的阶段，没有出现超时，而是收到三个重复的确认信息，就证明并网络并没有出现的拥塞，只是某个报文丢失了，就会进入快重传阶段，直接将拥塞值设置为发送窗口一半，然后发送窗口等于拥塞窗口，在继续拥塞避免阶段。

### time-wait

确保最后一个确认报文可以到达，如果服务端没有收到确认报文，那么就会重新发送释放请求报文，A等待这段时间就是为了处理这种情况。

让本连接中的所有报文都消失在网络中，使得下一个新连接不会出现旧的连接请求报文。