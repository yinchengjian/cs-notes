# Java 虚拟机

## 运行时数据区域

- 程序计数器：记录正在执行的虚拟机指令字节码的地址

- Java虚拟机栈：每个线程都会有一个栈帧，存放局部变量表，基础类型变量，以及引用等

- 本地方法栈：虚拟机通过JNI调用C，C++的代码，又被称为native方法，本地方法栈为本地方法服务的

- 堆：所有对象的分配都是在堆完成的，是垃圾回收的主要区域，分为新生代，老年代

- 方法区：是虚拟机的一种规范，用来存放类的元信息，静态变量，常量（String，Integer等），1.8之前都是通过永久代实现的，也是属于堆的一部分，Full GC也会影响到永久代的内存大小，但是由于对于这部分内存的不确定性，所以1.8之后把永久代移除，新增元空间，用于保存类信息，静态变量和常量池放在堆中，元空间是直接内存，也就和堆内存没有关系

- 运行时常量池：保存字面量和符号引用，一般都是String，Integer

- 直接内存：堆外内存，NIO中的native函数库可以直接分配堆外内存，通过Java堆中的DirectByteBuffer对象作为该内存的引用，避免了堆内存和堆外内存的来回拷贝数据


## 垃圾收集

### 判断是否可被回收

- 引用计数法：对象会有一个计数器，没有一个引用，就会加一，当计数器为0时，代表当前对象可以被回收，有可能会出现循环引用，A引用B，B引用A，两个对象都无法被回收
- 可达性分析法：根据GC Root 引用来作为起始点，一直向下搜索，最终没有被搜索到的即可被回收，GC Root：局部变量表的引用，静态变量的引用，常量的引用
- 方法区的回收：主要是对于常量池的回收以及类的卸载

### 引用类型

- 强引用：只要有该引用存在，就不会被回收

- 软引用：该引用会在内存不足的时候被回收

- 弱引用：该引用一定会被下次垃圾回收

- 虚引用：只是用于当该对象被回收时系统收到通知


### 垃圾收集算法

- 标记-清除：先把可回收对象标记起来，之后直接回收该对象的内存，被回收后的内存会判断是否有连续，如果连续，就会合并两个块，之后会把空闲的内存块放在一个空闲链表上，再分配时只用遍历该表既可分配内存，但是有个问题，会产生内存碎片，看着空闲内存很多，但是没有连续，导致一个大对象请求连续内存时就会分配失败

- 复制：把内存一分为二，只用其中的一块，当要回收内存时，把存活的对象全部复制到另一块区域，之后再把当前区域全部清除。存在的问题很明显：内存利用率不足，现在商业的虚拟机也都是这种类型的收集**新生代**，但是不同的是：并不是划分相同的两块，而是一个较大的Eden和两个较小的survivor空间，每次只是用Eden和其中一个survivor空间，回收时，把上面两个区域存活的对象全部复制到另一个survivor空间，之后清理上面的两个区域，如果survivor空间放不下全部的对象，需要向老年代进行空间分配担保

- 标记-整理：把所有存活的对象全部移动到内存的一端，然后清理掉超出边界的内存，需要移动大量内存，效率比较低

- 分代收集：按照不同代进行不同的收集策略，新生代使用复制算法，老年代采用标记清除或者标记整理


### 垃圾收集器

新生代：Serial，ParNew（可与CMS搭配使用），Parallel Scanvenge

老年代：CMS，Serial Old，Parallel Old

G1：不区分新生代，老年代

单线程和多线程：是指垃圾收集器使用单线程或者多线程

穿行和并行：串行是指用户和垃圾收集器交替执行，意味着在执行垃圾收集时必须要停顿用户线程，并行是两者一起执行，CMS和G1是并行，其余都是串行

#### CMS

标记清除，concurrent collection这个收集并不是Full GC，而是单纯的收集老年代的垃圾
初始标记：找出GC Root 需要停顿

并发标记：tracing过程

重新标记：修正并发标记过程中被用户改动过的引用对象，需要停顿

并发清除：清除对象

会出现浮动垃圾，在并发清除阶段用户又产生了新的垃圾，只能等到下次垃圾回收才能收集。所以需要预留出来一部分内存，用来存放浮动垃圾，如果该内存无法完全存放，就会出现Concurrent Mode Failure，这时会通过Serial Old代替CMS

还有就是内存碎片，无法分配大对象，就会导致Full GC

#### G1

新生代和老年代（ternured）一起收集，把堆分为多个大小相同的独立区域（Region），可预测的停顿：对于每个区域都会有基于以前的经验来记录回收的时间以及回收的空间，维护了一个优先队列，根据每次允许的收集时间，优先回收性价比高的区域，每个区域都存在一张remembered set，用来记录该表对象中引用对象所在的区域，可以避免全局扫描

初始标记

并发标记

最终标记：主要是把用户行为改变的那些引用记录到remembered set log中，之后同步到remembered set中

筛选回收：找出性价比高的区域回收	

## 内存分配和回收策略

### Minor GC和Full GC

minor GC：用来收集新生代的垃圾

concurrent collection/Mixed GC：收集老年代的垃圾

Full GC：是回收新生代和老年代，并且会停顿用户线程

### 内存分配策略

对象优先在Eden分配

大对象直接进入老年代

长期存活的对象进入老年代

动态对象年龄判定

空间分配担保

### FullGC触发条件

调用System.gc()

老年代空间不足

空间担保失败

concurrent mode failure

## 类加载机制

类的生命周期：加载，验证，准备，解析，初始化，使用，卸载

加载：通过全限定类名获取类的二进制字节流

将该字节流表示的静态存储结构转化为方法区的运行时存储结构

在内存中生成该类的class对象，作为方法区中该类各种数据的访问入口

验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

准备：是初始化静态变量

解析：将常量池的符号引用替换为直接引用的过程

初始化：执行Java代码

类初始化时机：主动引用，被动引用

## 类加载器

类和类加载器唯一确定一个类

启动类加载器

扩展类加载器

应用类加载器

自定义类加载器

## 双亲委派模型

一个类加载器首先将类加载请求转发给父类加载器，只有当父类加载器无法处理，才尝试自己处理

好处：使得Java类随着他的类加载器一起具有了优先级层次关系，从而使得基础类统一



