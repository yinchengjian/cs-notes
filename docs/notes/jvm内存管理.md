# java内存分区



![1544857553330](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1544857553330.png)

## 线程独占区

### 程序计数器

当前字节码执行的**行号指示器**（其实就是代码运行到哪个位置，记录下来，方便中断，分支，循环，跳转发生之后，还原现场。）

java虚拟机的多线程指的是多个线程轮流获取cpu，所以为了线程切换后能够恢复到正确的执行位置，每个线程都需要一个独立的程序计数器，各不影响，独立存储。这类内存区域为**线程私有化**的内存。

如果此时线程执行java方法，就会记录当前执行的虚拟机字节码指令的地址，如果是本地方法，就会为空，并且该位置不会发生内存溢出的错误。我想是因为该内存区域和整个java没有太大的联系，更加接近与机组的部分。

### 虚拟机栈

虚拟机栈描述的是java方法执行的内存模型。每个方法都会创建一个**栈帧**，用于存储**局部变量表**，操作数栈，动态链接，方法出口等信息。方法从调用到执行结束，就是栈帧入栈到出栈的过程。

局部变量表存放的编译期可知的各种基本数据类型，**对象引用类型**，此位置存放的有两种类型，会在后续讲解。

局部变量表所需的内存空间在**编译期间**就完成分配，当进入方法时，该方法**在帧中**所需要的内存时确定的，方法运行期间不会改变局部变量表的大小。long，double类型数据在2个局部变量空间，其余的只占1个。

问题：如果是name:String类型的局部变量，它的大小不确定，为什么局部变量表大小固定呢？

1. 在虚拟机栈中的局部变量表存储的是对象的引用，换句话说，其实就是该对象在java堆中的地址（其实也不太准确，因为有两种方式实现引用对象到实际对象内存的映射，在这我们姑且认为是这样并没有太大的问题。）所以这个引用name其实就是存放了一个地址，java堆地址的大小是固定的。

#### 异常状态

就是一个线程的方法（例如一个递归方法，或者有很多方法同时在执行）都会在该虚拟机栈中执行，如果一直方法在生成，就会栈溢出

![1544856859813](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1544856859813.png)

- StackOverflowError：就是爆栈了，我认为，就是说线程请求的栈深度大于虚拟机所允许的深度。
- OutOfMemoryError：如果虚拟机栈可以动态扩展，但是在扩展时无法申请到足够的内存。

看完这张虚拟机栈的图，我有点想明白了，好像一个类中的动态变量好像都没有讲在哪里存储，我们可以接着往下看，应该是在对象创建部分会提及。

### 本地方法栈

本地方法栈其实就是为虚拟机用到的本地方法服务。

## 线程共享区

### java堆

​	java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，用来**存放对象实例**，所有对象及数组都要在堆上分配内存。

​	堆可以处于物理上不连续的内存空间，只要逻辑上连续即可，就像我们磁盘一样，固定大小和可扩展都支持。如果没有内存分配给对象实例，也无法扩展时，就会出现内存溢出异常。

### 方法区

**运行时常量池**，虚拟机加载的**类信息**，常量静态变量，编译后的代码等信息。

它上面存储的是类的信息，也就是说当一个对象实例被创建时，会生成一个指针来指向它所属的类信息地址， 目的就是为了让对象和类型一致。

### **运行时常量池**

​	是方法区的一部分，永安里存放编译期生成的各种字面量和**符号引用**，是在类加载后进入方法区时存放的。

符号引用不明白

​	运行时常量池时具备动态性，可以以在运行期间将新的常量放入池中，最多的就是String.intern()。

### 直接内存

### 对象的创建

​	先会执行new指令，回去检查常量池中是否有该对象实例，如果有直接返回一个，否的话就需要执行相应的类加载过程。

​	类加载之后，在为新生对象分配内存，

指针碰撞

空闲列表

​	这两个分配方式主要取决于java堆是否规整，是否规整又取决于垃圾收集器是否带有压缩整理功能决定的，

​	并且对象创建的内存分配也会遇到线程安全问题，类如两个都在为他分配内存，一个已经指向了，另一个修改了该内存，那就出错了，

两种方案：

1. 为分配内存空间的动作进行同步处理，CAS加上失败重试方法来保证更新操作的原子性，
2. 把内存分配的动作按照线程划分到不同的空间，每个线程会预先在java堆中分配到一块内存，称为本地线程分配缓冲，

内存分配完成，将分配到的内存都初始化为零值（不包括对象头），保证对象不赋初始值也可以使用。

### 对象的内存布局

对象头

实例数据

对齐填充

对象头：1.存储对象自身运行时数据，hashcode，GC分代年龄等，

2.即使类型指针，目的是要指向他的类元数据，虚拟机通过该指针来确定对象属于哪个类，如果是数组，还要再再开一块数据来存储数组长度。

其他两个就不用讲了。

### 对象访问定位

通过虚拟机栈上的reference数据来操作具体对象，防卫方式有**使用句柄**和**直接指针**两种。

1.使用句柄：java堆绘画出一块内存作为句柄池，用来存储独享的句柄地址，而句柄中包含了对象实例的数据和类型数据各自的具体地址信息。

2.直接指针：引用指向java堆中实例对象，实例对象有关于对象类型的数据。

两个方式差别也很明显：

1中当对象被移动，只用改变句柄中实例对象的位置，

2中可以更加快捷，可以一次访问到实例对象，

## java堆溢出

```java
while(true){
    list.add(new object());
}
```

## 虚拟机栈溢出

```java
public void stackLeak(){
	stackLeak();
}//递归 
```

```java
while(true){
    Thread thread = new Thread(){
        public void run(){
            
        }
    }
}
```

方法区和运行时常量池溢出

```java
while(true){
    list.add(String.valueOf(i++).intern());
}
```

```java
String str1 = new StringBuider("计算机").append("软件").toString();
println(str1.intern()==str1);
String str2 = new StringBuilder.append("ja").append("va").toString();
println(str1.intern()==str1);
```

jdk1.7 会在常量池中记录首次出现的实力引用，所以就会返回true，因为java之前就在常量池中，所以这次的实力引用不会记录到常量池中，所以为false。

