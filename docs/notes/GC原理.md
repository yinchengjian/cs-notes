# GC原理及各收集器比较

## GC概述

- 那些内存需要回收
- 什么时候回收
- 如何回收


java内存运行时区域分为程序计数器，虚拟机栈，本地方法栈，方法区，java堆这几个区域。其中程序计数器，虚拟机栈，本地方法栈3个区域随线程而生，随线程而灭。

## 检测对象是否存活

### 1.引用计数算法

​	其实就是我们想的那么简单，就是在每一个对象身上添加一个引用计数器，一个地方引用它，就加1，引用失效，就减1，当引用计数为0时就证明没有人引用该对象。

​	问题：无法解决循环引用。淘汰！！！

### 2.可达性分析算法

​	算法基本思路：就是会通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，该过程做过的路径为**引用链**，当一个对象无法通过引用链到达roots时，证明该对象是不可用的。即可回收。

java中，可作为GC Roots对象的为：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中java native interface 引用的对象

## 垃圾收集算法

### 1.标记清除算法

​	如它的名字一样，分为标记，清除两个部分。首先标记出需要收集的对象，标记完成之后在统一回收。

​	问题：1.效率问题，标记，清除都要遍历。2.空间问题，清除之后会有内存碎片，当下一次较大的对象分配内存时，无法找到足够大的连续内存不得不提前触发另一次垃圾收集动作。

### 2.复制算法

​	复制算法是为了解决内存碎片问题，不过在此我并没有理解，它解决的是哪个问题，标记还是清除，想了想应该和清楚有关系，他的思路是这样的：

​	在堆中分配出两个大小相同的内存块，每次只用一个，当其中一个用完时，就将该内存块上还存活的对象复制到另一个内存块（依次按顺序分配），并就该块内存全部清理掉，这样就不会产生碎片问题，就是内存代价有点高。来回复制，降低效率。

​	商业用法：会创建Eden：Survivor = 8 ：1，有两块Survivor，每次使用一个Eden和一个Survivor，当回收时，将所有还存活的对象放到另一个Survivor中，最后清理掉上面两个区域，如果放不下的话就要像老年代进行**分配担保**。 

### 3.标记整理算法

一般用于老年代，将所有还存活的对象都向内存的一端移动，然后再清理到端边界以外的内存。

### 4.分代收集算法

​	根据年代来采用适合的收集算法。

### **GC术语**

​	为了理解ZGC如何匹配现有收集器，以及如何实现新GC，我们需要先了解一些术语。最基本的垃圾收集涉及识别不再使用的内存并使其可重用。现代收集器在几个阶段进行这一过程，对于这些阶段我们往往有如下描述：

- 并行- 在JVM运行时，同时存在应用程序线程和垃圾收集器线程。 并行阶段是由多个gc线程执行，即gc工作在它们之间分配。 不涉及GC线程是否需要暂停应用程序线程。
- 串行- 串行阶段仅在单个gc线程上执行。与之前一样，它也没有说明GC线程是否需要暂停应用程序线程。
- STW - STW阶段，应用程序线程被暂停，以便gc执行其工作。 当应用程序因为GC暂停时，这通常是由于Stop The World阶段。
- 并发 -如果一个阶段是并发的，那么GC线程可以和应用程序线程同时进行。 并发阶段很复杂，因为它们需要在阶段完成之前处理可能使工作无效（译者注：因为是并发进行的，GC线程在完成一阶段的同时，应用线程也在工作产生操作内存，所以需要额外处理）的应用程序线程。
- 增量 -如果一个阶段是增量的，那么它可以运行一段时间之后由于某些条件提前终止，例如需要执行更高优先级的gc阶段，同时仍然完成生产性工作。 增量阶段与需要完全完成的阶段形成鲜明对比。

### **权衡**

值得指出的是，所有这些属性都需要权衡利弊。 例如，并行阶段将利用多个gc线程来执行工作，但这样做会导致线程协调的开销。 同样，并发阶段不会暂停应用程序线程，但可能涉及更多的开销和复杂性，才能同时处理使其工作无效的应用程序线程。

## 垃圾收集器

### CMS(Concurrent Mark Sweep)收集器

目的：系统提顿时间最小，用于老年代

- 初始标记（单线程）
- 并发标记（并发）
- 重新标记（多线程）
- 并发清除（并发）

初始标记，重新标记还是会需要stw（stop the world）

初始标记仅仅标记与GCRoots直接关联的对象，速度比较快。

并发标记就是进行GC Roots Tracing过程，所有相关联对象全部标记，与用户线程并发执行。

重新标记为了修正并发标记过程中因用户程序继续运行而导致标记不一致的记录，所以会暂停用户线程。

​	整体分析：时间较长的步骤为并发标记和并发清除，这两个操作都是并发执行的，所以其实真正的停顿时间还是比较少的。

缺点：

- 对cpu资源非常敏感，因为并发标记和并发清除都是需要cpu分配一部分计算能力来运行线程，就会导致用户线程执行速度下降.
- CMS无法处理浮动垃圾。就是说当gc在并发清理期间用户线程依然在执行，并且可能会产生一些新的垃圾，但是本次gc又不能去清理它，只能等待下一次gc。并且由于用户线程也在运行，就需要给用户线程留出一部分内存，防止在gc执行期间用户线程分配不到内存而死掉。
- CMS是基于**标记清除**算法，会产生大量的空间碎片，因为用户进程并发执行，所以不可能进行内存整理啊，当下一个较大的对象无法分配足够的内存时，就会引起Full GC（老年代gc）。

### G1 收集器

​	用于新生代和老年代的，

收集器运作步骤：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

特点：

- 并行和并发：其实就是和CMS一样，可以和用户线程并行标记，并且可以多线程一起执行标记，回收。
- 分代收集：它自己可以进行分代收集，可以对于不同对象进行不同的收集策略。
- 空间整合：整体上用的是**标记整理**算法，局部用的是复制算法，所以不会产生内存碎片，我认为主要原因时G1在筛选回收时，采用的是多线程，暂停用户线程。
- 可预测的停顿：降低停顿时间，CMS和G1都一样，但是G1可以建立停顿时间模型，可以在指定时间内完成垃圾回收。。

问题：为什么可以达到可预测的停顿？

​	他将整个内存分为了多个大小相同的独立区域，可以跟踪每个区域的垃圾堆积价值大小（回收的空间以及回收所用的时间），并且在后台建了个优先级队列，目的就是为了在允许的时间内达到最大的垃圾收集效率。

问题：在这里优惠有一个问题，就是说，这些独立区域是怎么划分出来的，怎么能确保各个区域独立？每个对象都有可能和其他对象发生引用关系。（新生代和老年代之间的引用也有这个问题）

​	在这里虚拟机用了一个Remembered Set，就是说每个独立区域都有一个直接的set，在对该区域的引用对象进行写操作时，会检查该引用是不是在同一个区域，如果不在就会把引用对象的相关信息写进改set里，这样下一次垃圾回收时，就会直接找到被关联的引用对象，一并清除。

## Shenandoah垃圾收集器

总的来说，大部分垃圾回收器要么使用古老的标记并清除算法，要么使用分代算法，再结合并发和堆压缩。垃圾回收器多种多样，但没有一种回收器能够满足所有的需求，它们总要在某些方面做出折衷，并且不可避免地存在停顿时间。而Shenandoah最大的两个特点是它伸缩性和超低停顿时间。

Shenandoah最初的目标是把GC停顿时间降到10毫秒以下，并且对内存的支持扩展到TB级别。为了降低停顿时间，回收器需要使用更多的线程来并行处理回收任务。而要在降低停顿时间的同时能够支持更大的堆空间，回收器对CPU的多核处理能力提出了更高的要求。相比于CMS和G1，Shenandoah不仅进行并行的垃圾标记，在压缩堆空间时也是并行进行的。

Shenandoah把堆空间分为很多区域，例如整个堆空间是1G，如果每个区域是1M，那么就会有1000多个区域。传统的标记并清除回收器并没有区域的概念，而拷贝回收器一般也只有两个或少数几个区域。通过更细粒度的分区，Shenandoah可以优先对包含更多垃圾的区域进行回收，同时有助于并行回收工作的进行。

Shenandoah是一个标记拷贝回收器，它的回收工作分为两个阶段。第一个阶段是标记阶段。在这个阶段，回收器会对每个区域里的对象进行标记，并计算它们的数量。第二个阶段，回收器对源区域的对象进行扫描，并把存活对象拷贝到目标区域，然后源区域的内存就可以被释放。这两个阶段看似很简单，但要让整个过程并行进行，从而降低停顿时间，事情就会变得复杂很多。



![img](http://cr.openjdk.java.net/~shade/shenandoah/shenandoah-gc-cycle.png)

阶段大致如下：

1. **Init Mark** 启动并发标记。它为并发标记准备堆和应用程序线程，然后扫描根集。这是循环中的第一个暂停，最主要的消费者是根集扫描。因此，其持续时间取决于根集大小。
2. **并发标记**遍历堆，并跟踪可访问的对象。此阶段与应用程序一起运行，其持续时间取决于活动对象的数量和堆中对象图的结构。由于应用程序可以在此阶段自由分配新数据，因此在并发标记期间堆占用率会上升。
3. **Final Mark**通过耗尽所有挂起的标记/更新队列并重新扫描根集来完成并发标记。它还通过确定要撤离的区域（收集集），预先疏散一些根来初始化疏散，并且通常为下一阶段准备运行时间。这项工作的一部分可以在**并发预清洗**阶段**同时**完成。这是周期中的第二个暂停，这里消费者最主要的时间是排队并扫描根集。 
4. **并发清理**回收立即垃圾区域 - 即在并发标记之后检测到的没有活动对象的区域。
5. **并发撤离**将对象集合从集合集复制到其他区域。这是与其他OpenJDK GC的主要区别。此阶段再次与应用程序一起运行，因此应用程序可以自由分配。其持续时间取决于为循环选择的集合集的大小。
6. **Init Update Refs**初始化更新引用阶段。除了确保所有GC和应用程序线程都已完成疏散，然后为下一阶段准备GC之外，它几乎没有任何作用。这是周期中的第三次暂停，最短暂停。
7. **并发更新引用**遍历堆，并更新对并发撤离期间移动的对象的引用。 这是与其他OpenJDK GC的主要区别。 它的持续时间取决于堆中的对象数，但不依赖于对象图结构，因为它会线性扫描堆。此阶段与应用程序同时运行。
8. **最终更新Refs**通过重新更新现有根集来完成更新引用阶段。它还从集合集中回收区域，因为现在堆没有对它们的（陈旧）对象的引用。这是循环中的最后一次暂停，其持续时间取决于根集的大小。
9. **Concurrent Cleanup**  回收集合集区域，现在没有引用。

根集包括：线程局部变量，嵌入在生成的代码中的引用，实习的字符串，类加载器的引用（例如静态最终引用），JNI引用，JVMTI引用。具有较大的根集通常意味着使用Shenandoah的较长暂停，请参阅下面的诊断技术。

## ZGC垃圾收集器

​	Java 11包含一个全新的垃圾收集器--ZGC，它由Oracle开发，承诺在数TB的堆上具有非常低的暂停时间，支持TB级内存容量，暂停时间低（<10ms），对整个程序吞吐量的影响小于15%。 下面我们将介绍开发新GC的动机，技术概述以及由ZGC开启的一些可能性。为了实现其目标，ZGC给Hotspot Garbage Collectors增加了两种新技术：着色指针和读屏障。

### **着色指针**

​	着色指针是一种将信息存储在指针（或使用Java术语引用）中的技术 。GC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。

### **读屏障**

​	读屏障是每当应用程序线程从堆加载引用时运行的代码片段（即访问对象上的非原生字段non-primitive field）：

```text
void printName( Person person ) {
    String name = person.name;  // 这里触发读屏障
                                // 因为需要从heap读取引用 
                                // 
    System.out.println(name);   // 这里没有直接触发读屏障
}
```

​	在上面的代码中，String name = person.name 访问了堆上的person引用，然后将引用加载到本地的name变量。此时触发读屏障。 Systemt.out那行不会直接触发读屏障，因为没有来自堆的引用加载（name是局部变量，因此没有从堆加载引用）。 但是System和out，或者println内部可能会触发其他读屏障。

**这与其他GC使用的写屏障形成对比，例如G1。读屏障的工作是检查引用的状态，并在将引用（或者甚至是不同的引用）返回给应用程序之前执行一些工作。 在ZGC中，它通过测试加载的引用来执行此任务，以查看是否设置了某些位。 如果通过了测试，则不执行任何其他工作，如果失败，则在将引用返回给应用程序之前执行某些特定于阶段的任务。**

**由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。**

与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。

### **标记**

现在我们了解了这两种新技术是什么，让我们来看看ZG的GC循环。

GC循环的第一部分是标记。标记包括查找和标记运行中的应用程序可以访问的所有堆对象，换句话说，查找不是垃圾的对象。

ZGC的标记分为三个阶段。 第一阶段是STW，其中GC roots被标记为活对象。 GC roots类似于局部变量，通过它可以访问堆上其他对象。 如果一个对象不能通过遍历从roots开始的对象图来访问，那么应用程序也就无法访问它，则该对象被认为是垃圾。从roots访问的对象集合称为Live集。GC roots标记步骤非常短，因为roots的总数通常比较小。

该阶段完成后，应用程序恢复执行，ZGC开始下一阶段，该阶段同时遍历对象图并标记所有可访问的对象。 在此阶段期间，读屏障针使用掩码测试所有已加载的引用，该掩码确定它们是否已标记或尚未标记，如果尚未标记引用，则将其添加到队列以进行标记。

在遍历完成之后，有一个最终的，时间很短的的Stop The World阶段，这个阶段处理一些边缘情况（我们现在将它忽略），该阶段完成之后标记阶段就完成了。

### **重定位**

GC循环的下一个主要部分是重定位。重定位涉及移动活动对象以释放部分堆内存。 为什么要移动对象而不是填补空隙？ 有些GC实际是这样做的，但是它导致了一个不幸的后果，即分配内存变得更加昂贵，因为当需要分配内存时，内存分配器需要找到可以放置对象的空闲空间。 相比之下，如果可以释放大块内存，那么分配内存就很简单，只需要将指针递增新对象所需的内存大小即可。

ZGC将堆分成许多页面，在此阶段开始时，它同时选择一组需要重定位活动对象的页面。选择重定位集后，会出现一个Stop The World暂停，其中ZGC重定位该集合中root对象，并将他们的引用映射到新位置。与之前的Stop The World步骤一样，此处涉及的暂停时间仅取决于root的数量以及重定位集的大小与对象的总活动集的比率，这通常相当小。所以不像很多收集器那样，暂停时间随堆增加而增加。

移动root后，下一阶段是并发重定位。 在此阶段，GC线程遍历重定位集并重新定位其包含的页中所有对象。 如果应用程序线程试图在GC重新定位对象之前加载它们，那么应用程序线程也可以重定位该对象，这可以通过读屏障（在从堆加载引用时触发）实现，如流程图如下所示：

![1545476651551](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1545476651551.png)

这可确保应用程序看到的所有引用都已更新，并且应用程序不可能同时对重定位的对象进行操作。

GC线程最终将对重定位集中的所有对象重定位，然而可能仍有引用指向这些对象的旧位置。 GC可以遍历对象图并重新映射这些引用到新位置，但是这一步代价很高昂。 因此这一步与下一个标记阶段合并在一起。在下一个GC周期的标记阶段遍历对象对象图的时候，如果发现未重映射的引用，则将其重新映射，然后标记为活动状态。

## **概括**

试图单独理解复杂垃圾收集器（如ZGC）的性能特征是很困难的，但从前面的部分可以清楚地看出，我们所碰到的几乎所有暂停都只依赖于GC roots集合大小，而不是实时堆大小。标记阶段中处理标记终止的最后一次暂停是唯一的例外，但是它是增量的，如果超过gc时间预算，那么GC将恢复到并发标记，直到再次尝试。

## 收集器的比较

CMS有两个大暂停，并且用的是标记清除算法，会产生内存碎片。

- Mark Sweep算法会导致内存碎片比较多
- CMS的并发能力依赖于CPU资源，所以在CPU数少和CPU资源紧张的情况下，性能较差
- 并发清除阶段，用户线程依然在运行，所以依然会产生新的垃圾，此阶段的垃圾并不会再本次GC中回收，而放到下次。所以GC不能等待内存耗尽的时候才进行GC，这样的话会导致并发清除的时候，用户线程可以了利用的空间不足。所以这里会浪费一些内存空间给用户线程预留。

G1用的是标记整理算法，G1则是把内存分为多个大小相同的区域Region，每个Region拥有各自的分代属性，但这些分代不需要连续。

这样的分区可以有效避免内存碎片化问题。

但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。

为了解决这个问题，G1对于每个Region都维护一个Remembered Set，用于记录对象引用的情况。当GC发生的时候根据Remembered Set的引用情况去搜索。

在Region层面上，整体的算法偏向于Mark-Compact。因为是Compact，会影响用户线程执行，所以回收阶段需要STW执行。

Shenandoah相比于CMS和G1，Shenandoah不仅进行并行的垃圾标记，在压缩堆空间时也是并行进行的。

CMS是Mark-Sweep标记过期对象后原地回收，这样就会造成内存碎片，越来越难以找到连续的空间，直到发生Full GC才进行压缩整理。

ZGC是Mark-Compact ，会将活着的对象都移动到另一个Region，整个回收掉原来的Region。

而G1 是 incremental copying collector，一样会做压缩。

没有G1占内存的Remember Set，没有Write Barrier的开销

## 总结

参考文献：

https://www.jfokus.se/jfokus18/preso/Shenandoah-GC--What-We-Know-In-2018.pdf

https://wiki.openjdk.java.net/display/shenandoah/Main

https://www.jianshu.com/p/1db3e4a3dc9e

https://github.com/cncounter/gc-handbook/blob/master/04_GC_Algorithms_Implementations.md