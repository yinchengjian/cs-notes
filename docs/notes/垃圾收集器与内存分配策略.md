# 垃圾收集与内存分配策略

## 对象是否存活

### 1.引用计数算法

​	其实就是我们想的那么简单，就是在每一个对象身上添加一个引用计数器，一个地方引用它，就加1，引用失效，就减1，当引用计数为0时就证明没有人引用该对象。

​	问题：无法解决循环引用。淘汰！！！

### 2.可达性分析算法

​	算法基本思路：就是会通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，该过程做过的路径为**引用链**，当一个对象无法通过引用链到达roots时，证明该对象是不可用的。即可回收。

java中，可作为GC Roots对象的为：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中java native interface 引用的对象

### 3.引用

​	jdk1.2之前，引用定义为reference类型中的数据存储的时某一个内存区域的起始地址，即某一个对象的起始地址，看起来就有点弱，对象只有2种状态：被引用，未被引用。

​	无法表示那种如果系统资源够用的话，就可以保留，不够用，就回收的场景，一般此类对象处于缓存功能场景中。

​	1.2之后，引用分为：强引用，软引用，弱引用，虚引用。

- 强引用：就是new一个对象，只要引用还在，就不会被回收
- 软引用：一些有用但非必需的对象（举例。。。）。在系统将要发生内存溢出异常之前，会把该类对象列入回收范围并进行二次回收。
- 弱引用：一些非必需的对象（举例。。。），该类对象只能存活到下次垃圾回收之前，下次回收时，不管内存是否够用，都会回收此类对象。
- 虚引用：虚引用的存在对于对象的生存时间不会有任何影响，也无法通过虚引用来获取实例对象，唯一目的就是能在该对象被回收时收到一个系统通知。

### 生存还是死亡

对象可以通过finalize()方法将自己与任何对象取得联系，即可不死。不建议在该方法中写。

### 回收方法区

方法区其实就是放一些类信息，常量池，代码等等，也被称为永久代，回收效率比较低。

类被回收标志：

- 所有实例被回收
- 加载该类的ClassLoader被回收
- 该类对应的java.lang.class没有被引用，就是说不能通过反射来访问该类。（动态代理，cglib等）



## 垃圾收集算法

### 标记清除算法

​	如它的名字一样，分为标记，清除两个部分。首先标记出需要收集的对象，标记完成之后在统一回收。

​	问题：1.效率问题，标记，清除都要遍历。2.空间问题，清除之后会有内存碎片，当下一次较大的对象分配内存时，无法找到足够大的连续内存不得不提前触发另一次垃圾收集动作。

### 2.复制算法

​	复制算法是为了解决内存碎片问题，不过在此我并没有理解，它解决的是哪个问题，标记还是清除，想了想应该和清楚有关系，他的思路是这样的：

​	在堆中分配出两个大小相同的内存块，每次只用一个，当其中一个用完时，就将该内存块上还存活的对象复制到另一个内存块（依次按顺序分配），并就该块内存全部清理掉，这样就不会产生碎片问题，就是内存代价有点高。来回复制，降低效率。

​	商业用法：会创建Eden：Survivor = 8 ：1，有两块Survivor，每次使用一个Eden和一个Survivor，当回收时，将所有还存活的对象放到另一个Survivor中，最后清理掉上面两个区域，如果放不下的话就要像老年代进行**分配担保**。 

### 3.标记整理算法

一般用于老年代，将所有还存活的对象都向内存的一端移动，然后再清理到端边界以外的内存。

### 4.分代收集算法

​	根据年代来采用适合的收集算法。

## 收集算法的实现

1.枚举根节点

​	虚拟机应当有办法直接得知那个地方存放对象引用，HotSpot中使用了叫OopMap的数据结构来达到这个目的，类加载的时候就将所有信息写入，这样GC在扫描时就会有信息。

2.安全点

​	在知道根节点之后，又有了一个新的问题，什么时候可以尽心gc，很明显程序执行时并非所有地方都能停下来执行gc，所有要记录安全点，在安全点暂停，执行gc，一般都是在方法调用，循环跳转等指令产生安全点。

​	安全点有了，下一个问题又来了，如何在开始gc之前所有程线程都跑到安全点，抢先式中断，主动式中断，GC要执行时，不对线程操作，回去置一个标志，每个线程执行时都会区主动轮询该标志，若为真，就自己中断。

3.安全区域

​	线程挂起时，gc怎么办，就需要安全区域，在该区域中gc都是安全的。

## 垃圾收集器

并行：多线程并行gc，用户线程依然暂停

并发：用户线程和gc线程同时运行，不一定并行，交替执行，也可以是两个cpu，

### Serial收集器（复制算法）

​	单线程新生代，进行垃圾回收时，其他线程都要暂停，一般用于client模式下。

### ParNew收集器（复制算法）

​	多线程版本，用户线程依然暂停,无法和CMS搭配使用。

### Parallel Scavenge 收集器（复制算法）

​	关注点为尽可能缩短垃圾收集时用户线程的停顿时间，达到一个可控的吞吐量。运行用户代码时间/（用户+gc）

### Serial Old 收集器

单线程老年代版

### Parallel Old 收集器

多线程老年代版

### CMS(Concurrent Mark Sweep)收集器

目的：系统提顿时间最小，用于老年代

- 初始标记（单线程）
- 并发标记（并发）
- 重新标记（多线程）
- 并发清除（并发）

初始标记，重新标记还是会需要stw（stop the world）

初始标记仅仅标记与GCRoots直接关联的对象，速度比较快。

并发标记就是进行GC Roots Tracing过程，所有相关联对象全部标记，与用户线程并发执行。

重新标记为了修正并发标记过程中因用户程序继续运行而导致标记不一致的记录，所以会暂停用户线程。

​	整体分析：时间较长的步骤为并发标记和并发清除，这两个操作都是并发执行的，所以其实真正的停顿时间还是比较少的。

缺点：

- 对cpu资源非常敏感，因为并发标记和并发清除都是需要cpu分配一部分计算能力来运行线程，就会导致用户线程执行速度下降.
- CMS无法处理浮动垃圾。就是说当gc在并发清理期间用户线程依然在执行，并且可能会产生一些新的垃圾，但是本次gc又不能去清理它，只能等待下一次gc。并且由于用户线程也在运行，就需要给用户线程留出一部分内存，防止在gc执行期间用户线程分配不到内存而死掉。
- CMS是基于标记清除算法，会产生大量的空间碎片，因为用户进程并发执行，所以不可能进行内存整理啊，当下一个较大的对象无法分配足够的内存时，就会引起Full GC（老年代gc）。

### G1 收集器

​	用于新生代和老年代的，

收集器运作步骤：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

特点：

- 并行和并发：其实就是和CMS一样，可以和用户线程并行标记，并且可以多线程一起执行标记，回收。
- 分代收集：它自己可以进行分代收集，可以对于不同对象进行不同的收集策略。
- 空间整合：整体上用的是标记整理算法，局部用的是复制算法，所以不会产生内存碎片，我认为主要原因时G1在筛选回收时，采用的是多线程，暂停用户线程。
- 可预测的停顿：降低停顿时间，CMS和G1都一样，但是G1可以建立停顿时间模型，可以在指定时间内完成垃圾回收。。

问题：为什么可以达到可预测的停顿？

​	他将整个内存分为了多个大小相同的独立区域，可以跟踪每个区域的垃圾堆积价值大小（回收的空间以及回收所用的时间），并且在后台建了个优先级队列，目的就是为了在允许的时间内达到最大的垃圾收集效率。

问题：在这里优惠有一个问题，就是说，这些独立区域是怎么划分出来的，怎么能确保各个区域独立？每个对象都有可能和其他对象发生引用关系。（新生代和老年代之间的引用也有这个问题）

​	在这里虚拟机用了一个Remembered Set，就是说每个独立区域都有一个直接的set，在对该区域的引用对象进行写操作时，会检查该引用是不是在同一个区域，如果不在就会把引用对象的相关信息写进改set里，这样下一次垃圾回收时，就会直接找到被关联的引用对象，一并清除。

理解GC日志

垃圾收集器参数总结

## 内存分配和回收策略

### 对象优先在Eden分配

当Eden内存不足，会发生一次Minor GC ，其实就是要将Eden和from Survivor放满，当放不下时，就会进行MinorGC，然后将所有存活的对象往to Survivor里放，并且下次用Eden和to Survivor，如果to Survivor放不下，就会放到老年代中，

- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定

### 空间分配担保

会先去查看是最大可用连续空间够不够，确保MinorGC安全，如果否，查看HandlerPromotion-Failure是否允许担保失败，如果允许，继续检查老年代的最大连续空间是否大于以前晋升的平均大小，如果大于，会尝试进行MinorGC，如果小于或者不允许冒险，就只能进行一次老年代GC（Full）。



