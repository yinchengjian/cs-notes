# 数据库系统原理

## 事务

不可分割的一组操作，满足ACID特性

ACID

原子性：不可分割

一致性：事务执行前后，逻辑保持一致

隔离性：当前事务未执行完之前对其他事务不可见

持久性：事务一旦执行完成，永久有效

## 封锁

封锁粒度：行锁，表锁，粒度不同，代价也不同

### 封锁类型

读写锁：写写互斥，读写互斥，读读不互斥

意向锁：目的是减少判断该表是否已经被加锁的代价，每次加锁之前，都要加上对应的表级意向锁

### 封锁协议

#### 三级封锁协议

1.写一直加到事务结束，读不加锁，解决了丢失修改的问题，不能同时有两个事务对数据进行修改

2.写一直加到事务结束，读加到读完，解决了脏读问题（读到了一个中间数据，没用的）

3.写一直加到事务结束，读一直加到事务结束，解决了不可重复读（同一事务中两次读取结果相同）

#### 两段锁协议

- 在对数据进行读写之前，都要获取相应的锁
- 在释放锁之后，不能在获取锁

用于串行化，有一个加锁阶段，一个释放锁的阶段，两个阶段不能有交叉

串行化也可以是那种加锁解锁，加锁解锁

### 显示和隐式锁定

- select * lock in share mode
- select  * for update

## 隔离级别

读未提交：事务中没提交，也可见（写加锁到事务结束，读不加锁）

读已提交：事务对其他事务不可见（写加锁到事务结束，读完释放读锁）

可重复读：同一事务中读取相同数据结果相同（写锁和读锁都直到事务结束才释放）

串行化：事务串行化进行（全都是写锁）

## 多版本并发控制

mvcc：是锁的一个变种，减少加锁的代价，只适用于读已提交和可重复读级别，读未提交每次都是读取最新的，无需使用mvcc

版本号：

隐藏的列

Undo日志：会通过一个回滚指针来连接每一个快照

## Next-key locks

Record lock：索隐锁，锁定某一个索引

Gap lock：锁定索引之间的间隙

Next-key lock：上面两者的结合版

