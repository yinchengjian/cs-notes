# 索引

## B-tree

M路搜索树，一个节点最多有M-1个关键字，最少有2个，每个非叶子结点的指针是关键字+1个，用来表示范围，每个叶子节点都在同一层，每一个关键字都是一个数据data（指向关键字信息的指针）。

![1548406947880](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1548406947880.png)

### 自维护

自维护说的是为了维护书的B-树的性质，每当结点中新加入key，打破了规则，就会将会产生分裂，一般都是直接将中间的key移到父节点，删除key，直接将该key的其他节点移到父节点，父节点小于的key移到下面。

### 查找

二分查找

## B+tree

非叶子节点的字数指针与关键字相同，

子树指针p[i]是关键字key[i]，key[i+1]范围的。

内节点不存储data（指向关键字信息的指针），

所有叶节点都是一个链表（稠密索引），且有序。

非叶子结点相当于是叶子结点的索引（稀疏索引）

![1548408193495](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1548408193495.png)

## 对比

1.B+tree读取I/O次数更少，因为结点内存储的只是关键字，而B-tree节点内存储的是data，更大

2.B+tree的查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## MyISAM索引实现

![1548408347755](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1548408347755.png)



![1548408378852](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1548408378852.png)

## InnoDB

InnoDB的数据文件本身就是索引文件，而MyISAM则是数据和索引文件分离的，索引文件知识保存数据记录的地址，但是InnoDB中，表数据文件本身就是按照B+tree组织的索引结构，叶节点data保存了完整的数据记录，索引的key就是表的主键，

![1548408630159](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1548408630159.png)

![1548408644580](C:\Users\yinchengjian\AppData\Roaming\Typora\typora-user-images\1548408644580.png)

辅助索引的data值是主键的值，也就是说通过辅助索引查找的话，要检索两边：首先找到主键的值，然后通过主索引去找到记录。

### 缺点

不能使用过长的主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。

用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

## 对比

MyISAM:不支持事务，没有行级锁。

## 索引问题

### 提高检索速度

以前是双向链表将页面连在一起，现在是通过B+tree结构实现，可以直接类似二分查找的方式找页面，然后在单向链表找记录。

### 降低增删改的速度

B+tree需要维护自己的结构，就需要额外的时间

## 哈希索引

就是将key值变成了hash值，用来定位记录。

### 缺点

没法排序

没法范围查找

不支持**最左匹配原则**

但是一旦key有重复的，就会很慢。

## 聚集索引

主索引

## 非聚集索引

非主键索引

## 覆盖索引

要把查询出的列和索引对应起来，不用回表了。

- 现在我创建了索引`(username,age)`，在查询数据的时候：`select username , age from user where username = 'Java3y' and age = 20`。
- 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~



# 锁

## 隔离级别

### 读未提交

b在给a转前，已经修改，但是事务没结束，a发现已经改完了，然后b又rollback了，又变回原样了。

主要是因为b把写锁在修改成功后就释放了。然后a可以读，读完，b又改回去了。

### 读已提交

a在一次查询中读到的结果不同。

原因：a把读锁在读取结束就释放了，b在该段时间内修改了数据，

实现原理：读锁是加在读数据的时候，读完就释放了，而不是加在事务开始的时候，所以导致在同一事务中如果有两次读操作，可能会在这两次读操作之间有人改变了数据，

### 可重复读

加行级读锁到事务结束，加行级写锁到事务结束。可解决不可重复读。

### 串行化

加表级共享锁直到事务结束，写加表级排他锁直到事务结束

### MVCC

多版本并发控制，时存储引擎实现的，在行级锁之前的一个措施，就是可以减少锁的使用，就是直接在每行记录后面多加两个字段，创建时间和删除时间，里面存的时版本号，用来区分该行记录的。

select：会查询当前事务版本之前的记录，

insert：新的每一行都会保存当前的版本号。

delete：删除的版本号也会记录

update：分别记录之前的和新的。







