# 二叉树

## 先序，中序，后序遍历，递归和非递归

自己用一个栈压栈

先序：当前节点先压左孩子，再压右孩子

中序：当前节点不为空，一直把左孩子压栈

当前节点为空，就出栈，指向右孩子

后序：先按左右中（跟先序差不多）顺序遍历，每次遍历的节点压入另一个栈

## 直接打印一个二叉树，检查自己的二叉树调整对了没

## 在二叉树中找到一个节点的后继节点（中序遍历的顺序在后面）

有右子树，就是右子树最左的节点。

无右子树，哪个节点的左子树是以该节点结尾的。一直往上找父节点，如果是父节点的右孩子，就继续，直到为父节点的左孩子为止。

## 前驱怎么写？

自己想

## 二叉树的序列化和反序列化

按层序列化

## 判断一个二叉树是否为平衡二叉树

某个节点是否平衡？左树右树是否平衡？高度

### 二叉树套路

递归函数

## 搜索二叉树（不含重复节点）：每个节点左子树比他小，右子树比他大

二叉树中序遍历是升序的，是搜索二叉树，在中序遍历非递归版时判断大小

## 判断完全二叉树

用层次遍历，两个条件：左无右有s，左有右无，以及是否为叶节点

层次遍历，果然要用队列

深度遍历用栈

## 完全二叉树的节点个数（时间低于o（n））





